//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 10.0
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !NO_EXPORT_APP_MAIN
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("do_low_error", "false");
    action();
  }
#endif

  public void HDevelopStop()
  {
  }

  // Procedures 
  // External procedures 
  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image.
  public void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {



    // Local control variables 

    HTuple hv_MinWidth=new HTuple(), hv_MaxWidth=new HTuple();
    HTuple hv_MinHeight=new HTuple(), hv_MaxHeight=new HTuple();
    HTuple hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
    HTuple hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

    // Initialize local and output iconic variables 

    //This procedure opens a new graphics window and adjusts the size
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth = 500;
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth = 0;
      hv_MaxWidth = hv_WidthLimit.Clone();
    }
    else
    {
      hv_MinWidth = hv_WidthLimit[0];
      hv_MaxWidth = hv_WidthLimit[1];
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight = 400;
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight = 0;
      hv_MaxHeight = hv_HeightLimit.Clone();
    }
    else
    {
      hv_MinHeight = hv_HeightLimit[0];
      hv_MaxHeight = hv_HeightLimit[1];
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor = 1;
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal())/hv_ImageWidth)).TupleConcat(
          (hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax();
    }
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      hv_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal())/hv_TempWidth)).TupleConcat(
          (hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin());
    }
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    //Resize window
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"","",out hv_WindowHandle);
    HDevWindowStack.Push(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
    }

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen.
  public void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
  {


    // Local control variables 

    HTuple hv_ContinueMessage, hv_Row, hv_Column;
    HTuple hv_Width, hv_Height, hv_Ascent, hv_Descent, hv_TextWidth;
    HTuple hv_TextHeight;

    // Initialize local and output iconic variables 

    //This procedure displays 'Press Run (F5) to continue' in the
    //lower right corner of the screen.
    //It uses the procedure disp_message.
    //
    //Input parameters:
    //WindowHandle: The window, where the text shall be displayed
    //Color: defines the text color.
    //   If set to '' or 'auto', the currently set color is used.
    //Box: If set to 'true', the text is displayed in a box.
    //
    hv_ContinueMessage = "Press Run (F5) to continue";
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
        out hv_Height);
    HOperatorSet.GetStringExtents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", 
        out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
    disp_message(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-12, 
        (hv_Width-hv_TextWidth)-12, hv_Color, hv_Box);

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message.
  public void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
  {


    // Local control variables 

    HTuple hv_Red, hv_Green, hv_Blue, hv_Row1Part;
    HTuple hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
    HTuple hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
    HTuple hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1=new HTuple();
    HTuple hv_C1=new HTuple(), hv_FactorRow=new HTuple(), hv_FactorColumn=new HTuple();
    HTuple hv_Width=new HTuple(), hv_Index=new HTuple(), hv_Ascent=new HTuple();
    HTuple hv_Descent=new HTuple(), hv_W=new HTuple(), hv_H=new HTuple();
    HTuple hv_FrameHeight=new HTuple(), hv_FrameWidth=new HTuple();
    HTuple hv_R2=new HTuple(), hv_C2=new HTuple(), hv_DrawMode=new HTuple();
    HTuple hv_Exception=new HTuple(), hv_CurrentColor=new HTuple();

    HTuple   hv_Color_COPY_INP_TMP = hv_Color.Clone();
    HTuple   hv_Column_COPY_INP_TMP = hv_Column.Clone();
    HTuple   hv_Row_COPY_INP_TMP = hv_Row.Clone();
    HTuple   hv_String_COPY_INP_TMP = hv_String.Clone();

    // Initialize local and output iconic variables 

    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Column: The column coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically
    //   for each new textline.
    //Box: If set to 'true', the text is written within a white box.
    //
    //prepare window
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part, 
        out hv_Column2Part);
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin, 
        out hv_WidthWin, out hv_HeightWin);
    HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
    //
    //default settings
    if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Row_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Column_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Color_COPY_INP_TMP = "";
    }
    //
    hv_String_COPY_INP_TMP = (((""+hv_String_COPY_INP_TMP)+"")).TupleSplit("\n");
    //
    //Estimate extentions of text depending on font size.
    HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent, 
        out hv_MaxWidth, out hv_MaxHeight);
    if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
    {
      hv_R1 = hv_Row_COPY_INP_TMP.Clone();
      hv_C1 = hv_Column_COPY_INP_TMP.Clone();
    }
    else
    {
      //transform image to window coordinates
      hv_FactorRow = (1.0*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
      hv_FactorColumn = (1.0*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
      hv_R1 = ((hv_Row_COPY_INP_TMP-hv_Row1Part)+0.5)*hv_FactorRow;
      hv_C1 = ((hv_Column_COPY_INP_TMP-hv_Column1Part)+0.5)*hv_FactorColumn;
    }
    //
    //display text box depending on text size
    if ((int)(new HTuple(hv_Box.TupleEqual("true"))) != 0)
    {
      //calculate box extents
      hv_String_COPY_INP_TMP = (" "+hv_String_COPY_INP_TMP)+" ";
      hv_Width = new HTuple();
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
            hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
        hv_Width = hv_Width.TupleConcat(hv_W);
      }
      hv_FrameHeight = hv_MaxHeight*(new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          ));
      hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
      hv_R2 = hv_R1+hv_FrameHeight;
      hv_C2 = hv_C1+hv_FrameWidth;
      //display rectangles
      HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
      HOperatorSet.SetDraw(hv_WindowHandle, "fill");
      HOperatorSet.SetColor(hv_WindowHandle, "light gray");
      HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1+3, hv_C1+3, hv_R2+3, hv_C2+3);
      HOperatorSet.SetColor(hv_WindowHandle, "white");
      HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
      HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
    }
    else if ((int)(new HTuple(hv_Box.TupleNotEqual("false"))) != 0)
    {
      hv_Exception = "Wrong value of control parameter Box";
      throw new HalconException(hv_Exception);
    }
    //Write text.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
          )));
      if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
          "auto")))) != 0)
      {
        HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
      }
      else
      {
        HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
      }
      hv_Row_COPY_INP_TMP = hv_R1+(hv_MaxHeight*hv_Index);
      HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
      HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
          hv_Index));
    }
    //reset changed window settings
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, 
        hv_Column2Part);

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: Set font independent of OS
  public void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
      HTuple hv_Bold, HTuple hv_Slant)
  {


        // Local control variables 

        HTuple hv_OS, hv_Exception=new HTuple();
        HTuple hv_AllowedFontSizes=new HTuple(), hv_Distances=new HTuple();
        HTuple hv_Indices=new HTuple();

        HTuple   hv_Bold_COPY_INP_TMP = hv_Bold.Clone();
        HTuple   hv_Font_COPY_INP_TMP = hv_Font.Clone();
        HTuple   hv_Size_COPY_INP_TMP = hv_Size.Clone();
        HTuple   hv_Slant_COPY_INP_TMP = hv_Slant.Clone();

        // Initialize local and output iconic variables 

    //This procedure sets the text font of the current window with
    //the specified attributes.
    //It is assumed that following fonts are installed on the system:
    //Windows: Courier New, Arial Times New Roman
    //Linux: courier, helvetica, times
    //Because fonts are displayed smaller on Linux than on Windows,
    //a scaling factor of 1.25 is used the get comparable results.
    //For Linux, only a limited number of font sizes is supported,
    //to get comparable results, it is recommended to use one of the
    //following sizes: 9, 11, 14, 16, 20, 27
    //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
    //
    //input parameters:
    //WindowHandle: The graphics window for which the font will be set
    //Size: The font size. If Size=-1, the default of 16 is used.
    //Bold: If set to 'true', a bold font is used
    //Slant: If set to 'true', a slanted font is used
    //
    HOperatorSet.GetSystem("operating_system", out hv_OS);
    if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
        new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
    {
      hv_Size_COPY_INP_TMP = 16;
    }
    if ((int)(new HTuple((((hv_OS.TupleStrFirstN(2)).TupleStrLastN(0))).TupleEqual(
        "Win"))) != 0)
    {
      //set font on Windows systems
      if ((int)((new HTuple((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))).TupleOr(
          new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))))).TupleOr(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(
          "courier")))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Courier New";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Arial";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Times New Roman";
      }
      if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = 1;
      }
      else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = 0;
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_Slant_COPY_INP_TMP = 1;
      }
      else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Slant_COPY_INP_TMP = 0;
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      try
      {
        HOperatorSet.SetFont(hv_WindowHandle, ((((((("-"+hv_Font_COPY_INP_TMP)+"-")+hv_Size_COPY_INP_TMP)+"-*-")+hv_Slant_COPY_INP_TMP)+"-*-*-")+hv_Bold_COPY_INP_TMP)+"-");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        throw new HalconException(hv_Exception);
      }
    }
    else
    {
      //set font for UNIX systems
      hv_Size_COPY_INP_TMP = hv_Size_COPY_INP_TMP*1.25;
      hv_AllowedFontSizes = new HTuple();
      hv_AllowedFontSizes[0] = 11;
      hv_AllowedFontSizes[1] = 14;
      hv_AllowedFontSizes[2] = 17;
      hv_AllowedFontSizes[3] = 20;
      hv_AllowedFontSizes[4] = 25;
      hv_AllowedFontSizes[5] = 34;
      if ((int)(new HTuple(((hv_AllowedFontSizes.TupleFind(hv_Size_COPY_INP_TMP))).TupleEqual(
          -1))) != 0)
      {
        hv_Distances = ((hv_AllowedFontSizes-hv_Size_COPY_INP_TMP)).TupleAbs();
        HOperatorSet.TupleSortIndex(hv_Distances, out hv_Indices);
        hv_Size_COPY_INP_TMP = hv_AllowedFontSizes.TupleSelect(hv_Indices.TupleSelect(
            0));
      }
      if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))).TupleOr(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(
          "Courier")))) != 0)
      {
        hv_Font_COPY_INP_TMP = "courier";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "helvetica";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "times";
      }
      if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = "bold";
      }
      else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = "medium";
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("times"))) != 0)
        {
          hv_Slant_COPY_INP_TMP = "i";
        }
        else
        {
          hv_Slant_COPY_INP_TMP = "o";
        }
      }
      else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Slant_COPY_INP_TMP = "r";
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      try
      {
        HOperatorSet.SetFont(hv_WindowHandle, ((((((("-adobe-"+hv_Font_COPY_INP_TMP)+"-")+hv_Bold_COPY_INP_TMP)+"-")+hv_Slant_COPY_INP_TMP)+"-normal-*-")+hv_Size_COPY_INP_TMP)+"-*-*-*-*-*-*-*");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        throw new HalconException(hv_Exception);
      }
    }

    return;
  }

  // Local procedures 
  public void scanline_centers (HObject ho_Scanlines, out HTuple hv_CenterRows, out HTuple hv_CenterColumns)
  {


    // Local iconic variables 

    HObject ho_Scanline=null;


    // Local control variables 

    HTuple hv_NumberScanlines, hv_Index, hv_Rows=new HTuple();
    HTuple hv_Columns=new HTuple();

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Scanline);

    try
    {
      HOperatorSet.CountObj(ho_Scanlines, out hv_NumberScanlines);
      hv_CenterRows = new HTuple();
      hv_CenterColumns = new HTuple();
      for (hv_Index=1; hv_Index.Continue(hv_NumberScanlines, 1); hv_Index = hv_Index.TupleAdd(1))
      {
        ho_Scanline.Dispose();
        HOperatorSet.SelectObj(ho_Scanlines, out ho_Scanline, hv_Index);
        HOperatorSet.GetContourXld(ho_Scanline, out hv_Rows, out hv_Columns);
        hv_CenterRows = hv_CenterRows.TupleConcat(0.5*((hv_Rows.TupleSelect(0))+(hv_Rows.TupleSelect(
            (new HTuple(hv_Rows.TupleLength()))-1))));
        hv_CenterColumns = hv_CenterColumns.TupleConcat(0.5*((hv_Columns.TupleSelect(
            0))+(hv_Columns.TupleSelect((new HTuple(hv_Columns.TupleLength()))-1))));
      }
      ho_Scanline.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Scanline.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void translate_bar_code_status_id (HTuple hv_StatusID, out HTuple hv_MessageText)
  {


    // Local control variables 

    HTuple hv_Messages, hv_IndexStatus, hv_Msg=new HTuple();
    HTuple hv_StatusIDSplit=new HTuple(), hv_IndexSplit=new HTuple();
    HTuple hv_IndexMessage=new HTuple();

    // Initialize local and output iconic variables 

    hv_MessageText = new HTuple();
    hv_Messages = new HTuple();
    hv_Messages = hv_Messages.TupleConcat(0);
    hv_Messages = hv_Messages.TupleConcat("unknown decoding status.");
    hv_Messages = hv_Messages.TupleConcat(1);
    hv_Messages = hv_Messages.TupleConcat("success.");
    hv_Messages = hv_Messages.TupleConcat(2);
    hv_Messages = hv_Messages.TupleConcat("edges: not enough edges detected.");
    hv_Messages = hv_Messages.TupleConcat(3);
    hv_Messages = hv_Messages.TupleConcat("edges: not enough edges for a start, a stop and at least one data character.");
    hv_Messages = hv_Messages.TupleConcat(4);
    hv_Messages = hv_Messages.TupleConcat("edges: too many edges detected.");
    hv_Messages = hv_Messages.TupleConcat(5);
    hv_Messages = hv_Messages.TupleConcat("edges: center of scanline not within image domain.");
    hv_Messages = hv_Messages.TupleConcat(6);
    hv_Messages = hv_Messages.TupleConcat("decoding: could not find stop character.");
    hv_Messages = hv_Messages.TupleConcat(7);
    hv_Messages = hv_Messages.TupleConcat("decoding: could not find start and stop characters.");
    hv_Messages = hv_Messages.TupleConcat(8);
    hv_Messages = hv_Messages.TupleConcat("decoding: internal error when estimating the maximum string length.");
    hv_Messages = hv_Messages.TupleConcat(9);
    hv_Messages = hv_Messages.TupleConcat("decoding: internal error when decoding a single character.");
    hv_Messages = hv_Messages.TupleConcat(10);
    hv_Messages = hv_Messages.TupleConcat("decoding: number of wide bars of a single character is not equal to 2.");
    hv_Messages = hv_Messages.TupleConcat(11);
    hv_Messages = hv_Messages.TupleConcat("decoding: invalid encoding pattern.");
    hv_Messages = hv_Messages.TupleConcat(12);
    hv_Messages = hv_Messages.TupleConcat("decoding: invalid mix of character sets.");
    hv_Messages = hv_Messages.TupleConcat(13);
    hv_Messages = hv_Messages.TupleConcat("decoding: error decoding the reference to a human readable string.");
    hv_Messages = hv_Messages.TupleConcat(14);
    hv_Messages = hv_Messages.TupleConcat("decoding: could not detect center guard pattern.");
    hv_Messages = hv_Messages.TupleConcat(15);
    hv_Messages = hv_Messages.TupleConcat("decoding: could not detect left and/or right guard patterns.");
    hv_Messages = hv_Messages.TupleConcat(16);
    hv_Messages = hv_Messages.TupleConcat("decoding: could not detect add-on guard pattern.");
    hv_Messages = hv_Messages.TupleConcat(17);
    hv_Messages = hv_Messages.TupleConcat("decoding: could not detect enough finder patterns.");
    hv_Messages = hv_Messages.TupleConcat(18);
    hv_Messages = hv_Messages.TupleConcat("decoding: no segment found.");
    hv_Messages = hv_Messages.TupleConcat(19);
    hv_Messages = hv_Messages.TupleConcat("check: checksum test failed.");
    hv_Messages = hv_Messages.TupleConcat(20);
    hv_Messages = hv_Messages.TupleConcat("check: check of add-on symbol failed.");
    hv_Messages = hv_Messages.TupleConcat(21);
    hv_Messages = hv_Messages.TupleConcat("check: detected EAN-13 bar code type instead of specified type.");
    hv_Messages = hv_Messages.TupleConcat(22);
    hv_Messages = hv_Messages.TupleConcat("check: symbol region overlaps with another symbol region.");
    hv_Messages = hv_Messages.TupleConcat(1000);
    hv_Messages = hv_Messages.TupleConcat("White spaces too wide.");
    hv_Messages = hv_Messages.TupleConcat(1001);
    hv_Messages = hv_Messages.TupleConcat("White spaces too narrow.");
    hv_Messages = hv_Messages.TupleConcat(1002);
    hv_Messages = hv_Messages.TupleConcat("Bars too wide.");
    hv_Messages = hv_Messages.TupleConcat(1003);
    hv_Messages = hv_Messages.TupleConcat("Bars too narrow.");
    hv_Messages = hv_Messages.TupleConcat(1004);
    hv_Messages = hv_Messages.TupleConcat("Possible saturation of gray values.");
    hv_Messages = hv_Messages.TupleConcat(1005);
    hv_Messages = hv_Messages.TupleConcat("No composite component found.");
    //
    for (hv_IndexStatus=0; (int)hv_IndexStatus<=(int)((new HTuple(hv_StatusID.TupleLength()
        ))-1); hv_IndexStatus = (int)hv_IndexStatus + 1)
    {
      hv_Msg = "";
      HOperatorSet.TupleNumber(((hv_StatusID.TupleSelect(hv_IndexStatus))).TupleSplit(
          ";"), out hv_StatusIDSplit);
      for (hv_IndexSplit=0; (int)hv_IndexSplit<=(int)((new HTuple(hv_StatusIDSplit.TupleLength()
          ))-1); hv_IndexSplit = (int)hv_IndexSplit + 1)
      {
        hv_IndexMessage = hv_Messages.TupleFind(hv_StatusIDSplit.TupleSelect(hv_IndexSplit));
        if ((int)(new HTuple(hv_IndexMessage.TupleEqual(-1))) != 0)
        {
          //This should not happen! Just in case, the default
          //message for an unknown status is returned.
          hv_IndexMessage = 0;
        }
        hv_Msg = (hv_Msg+(hv_Messages.TupleSelect(hv_IndexMessage+1)))+" ";
      }
      //Remove the leading space
      hv_MessageText[hv_IndexStatus] = (hv_Msg.TupleStrFirstN((hv_Msg.TupleStrlen()
          )-2)).TupleStrLastN(0);
    }

    return;
  }

  // Main procedure 
  private void action()
  {

    // Local iconic variables 

    HObject ho_Image, ho_SymbolRegions=null, ho_CandidateRegions=null;
    HObject ho_ScanlinesAll=null, ho_ScanlinesValid=null;


    // Local control variables 

    HTuple hv_UserDefinedMessages, hv_StatusID=new HTuple();
    HTuple hv_Status=new HTuple(), hv_ImagePrefix, hv_ImageSuffix;
    HTuple hv_WindowHandle, hv_BarCodeHandle, hv_CodeType;
    HTuple hv_Count, hv_IndexExposure, hv_DecodedDataStrings=new HTuple();
    HTuple hv_NumInterestingCand=new HTuple(), hv_IndexCandidate=new HTuple();
    HTuple hv_String=new HTuple(), hv_StatusIDSplit=new HTuple();
    HTuple hv_CenterRows=new HTuple(), hv_CenterColumns=new HTuple();
    HTuple hv_Box=new HTuple(), hv_IndexStatus=new HTuple();

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_SymbolRegions);
    HOperatorSet.GenEmptyObj(out ho_CandidateRegions);
    HOperatorSet.GenEmptyObj(out ho_ScanlinesAll);
    HOperatorSet.GenEmptyObj(out ho_ScanlinesValid);

    try
    {
      //This example presents the bar code parameters 'status'
      //and 'status_id' that can be used within get_bar_code_result
      //to get additional information about possibly occuring
      //errors when reading a bar code.
      //
      //Remark: UserDefinedMessages set to false disables additional
      //diagnostic messages (overexposure) in this example program
      hv_UserDefinedMessages = 1;
      if ((int)(new HTuple(hv_UserDefinedMessages.TupleEqual(0))) != 0)
      {
        hv_StatusID = "-1";
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
      }
      // dev_close_inspect_ctrl(...); only in hdevelop
      // dev_update_pc(...); only in hdevelop
      // dev_update_window(...); only in hdevelop
      hv_ImagePrefix = "barcode/25interleaved/25interleaved_exposure_";
      hv_ImageSuffix = ".png";
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, (hv_ImagePrefix+"01")+hv_ImageSuffix);
      dev_open_window_fit_image(ho_Image, 0, 0, -1, -1, out hv_WindowHandle);
      set_display_font(hv_WindowHandle, 14, "mono", "true", "false");
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
      }
      //
      //If get_bar_code_result is called with the parameter 'status',
      //'persistence' must be set for the bar code model
      HOperatorSet.CreateBarCodeModel("persistence", 1, out hv_BarCodeHandle);
      //
      //For the visualization, the number of scanlines is reduced
      //(default is 10)
      HOperatorSet.SetBarCodeParam(hv_BarCodeHandle, "num_scanlines", 5);
      HOperatorSet.SetBarCodeParam(hv_BarCodeHandle, "check_char", "present");
      //
      //
      hv_CodeType = "2/5 Interleaved";
      hv_Count = 5;
      for (hv_IndexExposure=1; hv_IndexExposure.Continue(hv_Count, 1); hv_IndexExposure = hv_IndexExposure.TupleAdd(1))
      {
        ho_Image.Dispose();
        HOperatorSet.ReadImage(out ho_Image, (hv_ImagePrefix+(hv_IndexExposure.TupleString(
            "02")))+hv_ImageSuffix);
        //
        //Try decoding the bar code in the input image
        ho_SymbolRegions.Dispose();
        HOperatorSet.FindBarCode(ho_Image, out ho_SymbolRegions, hv_BarCodeHandle, 
            hv_CodeType, out hv_DecodedDataStrings);
        ho_CandidateRegions.Dispose();
        HOperatorSet.GetBarCodeObject(out ho_CandidateRegions, hv_BarCodeHandle, 
            "all", "candidate_regions");
        if ((int)(new HTuple((new HTuple(hv_DecodedDataStrings.TupleLength())).TupleGreater(
            0))) != 0)
        {
          //If a bar code was found, display only scanlines of
          //successfully decoded regions (which are the first
          //regions of all candidate regions)
          HOperatorSet.CountObj(ho_SymbolRegions, out hv_NumInterestingCand);
        }
        else
        {
          //If no bar code could be found, display the error
          //information for all candidate regions
          HOperatorSet.CountObj(ho_CandidateRegions, out hv_NumInterestingCand);
        }
        //
        //Iterate over all symbol regions or candidate regions
        //if no symbol could be decoded
        for (hv_IndexCandidate=0; hv_IndexCandidate.Continue(hv_NumInterestingCand-1, 1); hv_IndexCandidate = hv_IndexCandidate.TupleAdd(1))
        {
          //
          //Display valid scanlines in green, invalid
          //scanlines in red
          ho_ScanlinesAll.Dispose();
          HOperatorSet.GetBarCodeObject(out ho_ScanlinesAll, hv_BarCodeHandle, hv_IndexCandidate, 
              "scanlines_all");
          ho_ScanlinesValid.Dispose();
          HOperatorSet.GetBarCodeObject(out ho_ScanlinesValid, hv_BarCodeHandle, 
              hv_IndexCandidate, "scanlines_valid");
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "red");
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ScanlinesAll, HDevWindowStack.GetActive());
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "green");
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ScanlinesValid, HDevWindowStack.GetActive());
          }
          //
          //Display the index number of the current candidate
          disp_message(hv_WindowHandle, (("Candidate "+(hv_IndexCandidate+1))+" of ")+hv_NumInterestingCand, 
              "image", 72, 12, "forest green", "true");
          //
          if ((int)(hv_UserDefinedMessages) != 0)
          {
            //
            //Get a tuple of strings containing multiple status
            //identifiers, separated by a semicolon
            HOperatorSet.GetBarCodeResult(hv_BarCodeHandle, hv_IndexCandidate, "status_id", 
                out hv_StatusID);
            //
            //This user-defined procedure can be modified to
            //translate status identifiers to customized status
            //messages
            translate_bar_code_status_id(hv_StatusID, out hv_Status);
          }
          else
          {
            //
            //Get tuple of strings containing status messages
            HOperatorSet.GetBarCodeResult(hv_BarCodeHandle, hv_IndexCandidate, "status", 
                out hv_Status);
          }
          //
          //Show decoded bar code data
          if ((int)(new HTuple((new HTuple(hv_DecodedDataStrings.TupleLength())).TupleGreater(
              0))) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), "green");
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ScanlinesValid, HDevWindowStack.GetActive()
                  );
            }
            hv_String = "Decoded data strings: "+hv_DecodedDataStrings;
            //
            //Combinations of status IDs can be combined to
            //give further hints for the image acquisition,
            // e.g. about a possible overexposure
            HOperatorSet.TupleNumber(hv_StatusID.TupleSplit(";"), out hv_StatusIDSplit);
            if ((int)((new HTuple(((hv_StatusIDSplit.TupleFind(1000))).TupleNotEqual(
                -1))).TupleAnd(new HTuple(((hv_StatusIDSplit.TupleFind(1004))).TupleNotEqual(
                -1)))) != 0)
            {
              hv_String = hv_String.TupleConcat("Possible overexposure detected.");
            }
            disp_message(hv_WindowHandle, hv_String, "image", 12, 12, "forest green", 
                "true");
          }
          else
          {
            disp_message(hv_WindowHandle, "Could not decode bar code", "image", 12, 
                12, "red", "true");
          }
          //
          //Display the index number of each scanline at its center
          scanline_centers(ho_ScanlinesAll, out hv_CenterRows, out hv_CenterColumns);
          //
          //If the scanlines lie to close to each other, omit the
          //background boxes
          if ((int)(new HTuple(((((((hv_CenterRows.TupleSelect((new HTuple(hv_CenterRows.TupleLength()
              ))-2))-(hv_CenterRows.TupleSelect((new HTuple(hv_CenterRows.TupleLength()
              ))-1)))).TuplePow(2))+((((hv_CenterColumns.TupleSelect((new HTuple(hv_CenterColumns.TupleLength()
              ))-2))-(hv_CenterColumns.TupleSelect((new HTuple(hv_CenterColumns.TupleLength()
              ))-1)))).TuplePow(2)))).TupleGreater(200*200))) != 0)
          {
            hv_Box = "true";
          }
          else
          {
            hv_Box = "false";
          }
          for (hv_IndexStatus=0; (int)hv_IndexStatus<=(int)((new HTuple(hv_Status.TupleLength()
              ))-1); hv_IndexStatus = (int)hv_IndexStatus + 1)
          {
            disp_message(hv_WindowHandle, ""+hv_IndexStatus, "image", hv_CenterRows.TupleSelect(
                hv_IndexStatus), hv_CenterColumns.TupleSelect(hv_IndexStatus), "green", 
                hv_Box);
          }
          // dev_inspect_ctrl(...); only in hdevelop
          if ((int)((new HTuple(hv_IndexCandidate.TupleLess(hv_NumInterestingCand-1))).TupleOr(
              new HTuple(hv_IndexExposure.TupleLess(hv_Count)))) != 0)
          {
            disp_continue_message(hv_WindowHandle, "black", "true");
            HDevelopStop();
          }
        }
      }
      //
      //Free all memory of the bar code model
      HOperatorSet.ClearBarCodeModel(hv_BarCodeHandle);
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_SymbolRegions.Dispose();
      ho_CandidateRegions.Dispose();
      ho_ScanlinesAll.Dispose();
      ho_ScanlinesValid.Dispose();

      throw HDevExpDefaultException;
    }
    ho_Image.Dispose();
    ho_SymbolRegions.Dispose();
    ho_CandidateRegions.Dispose();
    ho_ScanlinesAll.Dispose();
    ho_ScanlinesValid.Dispose();

  }


}
#if !NO_EXPORT_APP_MAIN
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

